
Ответы на вопросы к экзамену по программированию

---
# Основы
---

## 1. Понятие и виды лексем

Единица текста программы

- Идентификаторы
- Ключевые слова
- Знаки операций
- Константы
- Комментарии

## 2. Структура и основные элементы программы

- Включение в состав другого файла
```cpp
#include <iostream>
```

- Использование пространства имён по умолчанию
```cpp
using namespace std;
```

- Точка входа м параметрами
```cpp
int main(int argc, char *argv[])
```

- Код завершения
```cpp
return 0;
```

---
# Переменные
---

## 3. Общее понятие типов данных

Тип указывает допустимые значения переменной, её объём, и допустимые операции

## 4. Переменные и константы
Переменные - область памяти, изменяемая значения по ходу программы
Константы - неизменяемая область памяти

## 5. Основные типы данных
- int
- short
- long
- float
- double
- bool
- char

## 6. Спецификаторы типов данных
- short
- long
- signed
- unsigned

## 7. Определение переменных и констант в программе

```cpp
// [класс памяти] <тип данных> <имя> [инициализатор];
unsigned int a = 2;
```

## 8. Инициализация переменных различных типов
```cpp
int a     = 0;
double b  = 0.0;
char c    = 'c';
char* e   = "text"; 
```

## 9. Целочисленные типы данных
int, long (доп. short, char)
- x86 -> 2 bytes
- x64 -> 4 bytes

## 10. Вещественные типы данных
double -> 8 bytes

float  -> 4 bytes

## 11. Особенности представления вещественных типов данных
Первый бит отводится под знак

## 12. Логический тип данных
bool -> 1 байт

## 13. Символьный тип данных
char -> 1 байт

---
# Операции
---

## 14. Управляющие последовательности
Особые символы

\n \t

## 15. Операции и выражения

~ ! - + * / % << \>> == != & ^ | $$ || 

?:

## 16. Операция присваивания, составные операции присваивания

= += -= ...

## 17. Понятие L-значения
Переменной присваивается значение слева

<< 

## 18. Преобразование типов данных
Если один из операндов ..., то все приводятся к ...

- char, short, int -> int
- double -> double 
- float -> float
- long -> long
- unsigned -> unsigned

## 19. Арифметические операции

\+ \- * / % 

## 20. Операции инкремента и декремента, их разновидности

++ -- 

## 21. Операции отношения

== != > < >= <=

## 22. Логические операции

! && ||

## 23. Побитовые операции сдвига

\>> <<

## 24. Побитовые логические операции

~ & | ^

## 25. Примеры применения побитовых операций

```cpp
// 2 << 1 == 4
// 2 && 0 == 0
// 2 && 1 == 0
// 2 || 1 == 3
```

## 26. Условная операция и ее использование

<условие>? <1> : <2>

## 27. Определение объема памяти, необходимого для размещения объектов

```cpp
int a = 2;
// sizeof int == sizeof a
```

## 28. Понятие приоритета операций и его влияние на результаты вычислений

1. a++
2. ++a
3. !
4. арифметические
5. логические

---
# Ввод и вывод
---

## 29. Вывод простых типов данных на экран

```cpp
// C-like
printf("text");
scanf("%d", $a);

// stdio.h
cout << "text" << endl; 
cin >> a;
```

## 30. Ввод данных с клавиатуры

```cpp
// C-like
scanf("%d", $a);

// stdio.h
cin >> a;
```

## 31. Флаги форматирования потоков ввода-вывода
ios::
- uppercase
- left
- right
- dec
- hex
- fixed

## 32. Форматирование ввода-вывода с помощью манипуляторов

- uppercase
- left
- right
- dec
- hex
- endl
- flush
- ws

## 33. Форматирование ввода-вывода с помощью функций потоков ввода-вывода

```cpp
cout.flags(0);
cout.setf(ios::showpos);
cout.unsetf(ios::hex);
```

## 34. Управление шириной поля вывода и выравниванием данных при выводе

- adjustfield - left, right, internal
- width - ширина поля вывода
- fill - символ заполнения

## 35. Управление форматом вывода вещественных значений

- floatfield - scientific, fixed
- precision - точность вещественного числа

--- 
# if, switch
---

## 36. Основные понятия структурного программирования

- Программа должна составляться достаточно мелкими шагами, так чтобы реализация каждого шага не вызывала никаких затруднений
- Сложная задача должна разбиваться на достаточно простые
- логика программы должна опираться на минимальное число достаточно простых базовых управляющих структур

## 37. Базовый набор управляющих структур
- Последовательность
- Выбор
- Итерации

## 38. Управляющие структуры и инструкции языка C++

- Последовательность
	+ break
	+ continue
	+ return
	+ goto
- Выбор:
	+ if
	+ switch
- Итерации
	+ while
	+ do while
	+ for

## 39. Условная инструкция (if)
Условная инструкция if позволяет выбрать одно из двух направлений выполнения программы.
```cpp
if(value) {
	// code
}else {
	// code
}
```

## 40. Инструкция множественного выбора (switch)
Эта инструкция служит для ветвления программы во многих направлениях.
```cpp
switch(value){
	case 1:
		// code
		break;
	case 2:
	case 3:
		// code
		break;
	default:
		// code
		break;
}
```

---
# Циклы
---

## 41. Цикл с предусловием (while)
```cpp 
while(value){
	// code
}
```

## 42. Цикл с постусловием (do while)
Проходит один раз, и после проверяет условие
```cpp 
do{
	// code
}while(value)
```

## 43. Итерационный цикл (for)
```cpp
for(int i = 0; i < 10; i++){
	// code
}
```

## 44. Инструкция перехода break
Останавливает текущий цикл и выходит из него

## 45. Инструкция перехода continue
Останавливает текущий цикл и переходит к следующему

## 46. Инструкция перехода goto
Инструкция goto обеспечивает переход на выполнение инструкции отмеченной с помощью метки.
```cpp
myLabel: 
while(true){
	while(true){
		break myLabel;
	}
}
```

## 47. Понятие рекуррентных вычислений, примеры
Вычисление, где следующее значение зависит от предыдущего. Факториал

## 48. Понятие инварианта цикла
Инвариантом называется логическое выражение, истинное перед началом выполнения цикла и после каждого проходатела цикла, зависящее от переменных, изменяющихся в теле цикла.

---
# Массивы
---

## 49. Понятие и определение массива
Последовательность однотипных элементов с определенным количеством

## 50. Одномерные и многомерные массивы
Одномерный массив = линия элементов
Многомерный массив = таблица элементов

## 51. Вывод элементов массива на экран
```cpp
auto a = int[3]{1, 2, 3};

for(int i = 0; i < 3; i++)
	cout << a[i];
```

## 52. Ввод элементов массивов с клавиатуры

```cpp
auto a = int[3];

for(int i = 0; i < 3; i++)
	cin >> a[i];
```

## 53. Декларативная и программная инициализация массивов
Декларативная - заполнение при инициализации
Программная - заполнение при выполнении программы

## 54. Копирование массивов

```cpp
#include <string.h>

memcpy(arr1, arr2, sizeof(arr1));
```

## 55. Нахождение минимальных и максимальных значений в массивах

```cpp
int min = -999999;
int max = -min;

for(int i = 0; i < 10; i++){
	if(arr[i] < min)
		min = arr[i];
	if(arr[i] > max)
		max = arr[i];
}
```

## 56. Сдвиг элементов массивов
```cpp
int size = 10;

// >>>>>>
for(int i = 0; i < size; i++)
	arr[(i+1) % size] = arr[i];

// <<<<<<
for(int i = 0; i < size; i++)
	arr[i] = arr[(i+1) % size];
```

## 57. Перестановка элементов в массивах
```cpp
for(int i = 0; i < size; i+=2){
	int buf = arr[i];
	arr[i] = arr[i+1];
	arr[i+1] = buf;
}
```

## 58. Поиск данных в массивах
```cpp
int toFind = 135;

for(int i = 0; i < size; i++){
	if(arr[i] == toFind){
		cout << "Found" << endl;
		break;
	}
	if(i == size-1)
		cout << "Not found" << endl;
}

```

## 59. Сортировка данных в массивах
```cpp
for(int i = 0; i < size; i++){
	for(int r = 0; r < size-1; r++){
		if(arr[r] > arr[r+1]){
			int buf = arr[i+1];
			arr[i+1] = arr[i];
			arr[i] = buf;
		}
	}
}
```

## 60. Вычисление сумм и произведений элементов массивов
```cpp
int mult = 1;
int sum = 0;

for(int i = 0; i < size; i++){
	mult *= arr[i];
	sum += arr[i];
}
```

---
# Строки
---

## 61. Представление текстовых строк в виде массива символов
```cpp
char name[6] = "Nikita";
```

## 62. Ввод-вывод символьных строк
```cpp
char* name;

cin >> name;
cout << "Your name is " << name << endl;
```

## 63. Определение фактической длины строки
```cpp
strlen("This is text");
```

## 64. Копирование символьных строк
```cpp
char* text1 = "Text 1";
char* text2 = "Text 2";

strcpy(text2, text1); // text2 = 'Text 1'
```

## 65. Основные функции обработки строк библиотеки cstring
- strlen
- strcpy
- strcmp
- strcat

## 66. Массивы текстовых строк (двумерные массивы символов)
```cpp
char arr_str[30][21];
strcpy(arr_str[10] , "Иванов");
cout << arr_str[10] << endl; // Иванов
```

---
# Указатели
---

## 67. Указатели
Адрес переменной
```cpp
int a = 2;
int b = *a; // Указатель на a
int c = $b; // Значение а по её ссылке
int d = $(*a); // То же, что и c
```

## 68. Арифметика указателей
Все арифметические операции

## 69. Индексирование указателей
```cpp
int arr[10];

int *p;
p = arr;
```

## 70. Ссылки
```cpp
int value = 15;
int $link = value;

value += 30;
// value = 30
// link  = 30

```

---
# Функции
---

## 71. Определение функции
Подпрограмма, которую можно вызывать. Содержит заголовок и тело.
```cpp
int a(int b){
	return b + 10;
}
```

## 72. Инструкция return
Прерывает выполнение функции, и возвращает значение из неё.

## 73. Завершение работы функции
С помощью return

## 74. Механизмы передачи данных через параметры функций
Параметры пишутся в скобочках как переменные

## 75. Передача данных по значению
```cpp
int c = pow(b);

int pow(int c){
	return c * c;
}
```

## 76. Передача данных через указатели
```cpp
int c = pow($b);

int pow(int *c){
	return &c * &c;
}
```

## 77. Передача данных по ссылке
```cpp
powThis(a);

void powThis(int $c){
	c *= c;
}
```

## 78. Понятие указателя
Адрес в памяти

## 79. Арифметика указателей
(Где-то выше)

## 80. Указатели и массивы
```cpp
char name[6] = "Nikita";

char *lnq = name;
```

---
# Структуры
---

## 81. Определение структур
Совокупность переменных, объединенных одним именем
```cpp
struct myStructure {
	int a;
	int b;
};
```

## 82. Доступ к полям структур

```cpp
struct {
	int myVar = 0;
} a;

cout << a.myVar << endl;
```

## 83. Указатели на структуры

```cpp
struct {
	int myVar = 0;
} a;

int b = *a;

cout << b->myVar << endl;
```
